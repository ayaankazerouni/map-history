# Map history
<small>See [this GitHub repo](https://github.com/ayaankazerouni/world-events) to see how event data was obtained, plus some limitations.</small>
---

<small>
Hover over points on the map to see event descriptions (sourced from Wikipedia's "on this day" pages).

**Zoom and move around**:

* <kbd>Click</kbd> to zoom in.
* <kbd>Shift + click</kbd> to zoom out.
* <kbd>Ctrl/Cmd + click</kbd> to move/pan
* <kbd>Double-click</kbd> to reset.

</small>

---

<style>
  .tippy-content {
    font-size: 0.8em;
    border: 1pt solid black;
    border-radius: 5px;
    background-color: var(--theme-background);
    padding: 10px;
  }
</style>

<small>Multiple selections will also include all events in between those year ranges.</small>

```js
const ranges = view(Inputs.checkbox(
  [ "Pre-1600", "1600-1899", "1900-1949", "1950-1999", "2000-2024" ],
  {
    value: "1600-1899",
    valueof: el => ({
      "Pre-1600": { start: -1500, end: 1600 },
      "1600-1899": { start: 1600, end: 1899 },
      "1900-1949": { start: 1900, end: 1940 },
      "1950-1999": { start: 1950, end: 1999 },
      "2000-2024": { start: 2000, end: 2025 }
    }[el]),
    disabled: !!searchTerms.length,
  }
));
```

```js
const searchTerms = view(Inputs.text({
  label: 'Events containing the word or phrase',
  placeholder: 'e.g., Gandhi',
  width: 500,
  submit: true
}));
```

```js
const marginLeft = width / 3; 
const legendWidth = (width / 3) + marginLeft;
const legend = Plot.legend({
  color: yearColorScale,
  domain: d3.extent(eventsToDraw.map(e => e.year)),
  width: legendWidth,
  tickFormat: yearFormat,
  marginLeft: marginLeft,
  label: (ranges.length || searchTerms) ? '' : 'Select a year range or type a search term to see events.'
})
display(legend)
```

<div style="text-align: center">
&#x1F50E;       ${100 - (radius / 90) * 100}% 
</div>

```js
```

```js
const map = Plot.plot({
  width: width,
  height: 500,
  projection: projection,
  marks: [
    Plot.geo(land, { stroke: 'black', fill: 'lightgrey' }),
    Plot.sphere(),
    Plot.dot(eventsToDraw, {
      x: 'longitude',
      y: 'latitude',
      r: 4,
      fill: e => yearColorScale.apply(e.year),
      stroke: yearColorScale,
      title: (d) => d.description,
      className: 'datapoint',
    }), 
  ]
});

d3.select(map)
  .on('click', (e) => {
    const newFocus = projection.invert(d3.pointer(e));
    let newRadius;
    if (e.shiftKey) {
      newRadius = radius * 2 >= 90 ? 90 : radius * 2;
    } else if (e.ctrlKey || e.metaKey) {
      newRadius = radius;
    } else {
      newRadius = radius / 2 < 5 ? radius : radius / 2;
    }

    setRadius(newRadius);
    setCenter(newFocus);
  })
  .on('dblclick', (_) => {
    setRadius(90);
    setCenter([0, 0]);
  });

// Tooltips using Tippy.js, code from this notebook: https://observablehq.com/d/baeb8cbead1ed3d2
d3.select(map).select('.datapoint')
  .selectAll('circle')
  .each(function () {
    // Grab the title generated by Plot
    const title = d3.select(this).select('title').text();

    // Apply tippy to the DOM element to attach groovy tooltips
    tippy(this, {
      content: tipText(title),
      // theme: "light-border",
      allowHTML: true,
      interactive: true,
      appendTo: () => document.body
    });
  })
  // Remove the native tooltip generated by Plot.
  .selectAll("title")
  .remove();

display(map);
```

```js
const center = Mutable([0, 0]);
const setCenter = (c) => center.value = c;

const radius = Mutable(90);
const setRadius = (r) => radius.value = r;
```

```js
const projection = d3.geoEqualEarth()
  .fitSize([width, 500], d3.geoCircle().center(center).radius(radius)());
```

```js
const colorScheme = window.matchMedia('(prefers-color-scheme: dark').matches ?
  'oranges' : 'blues'
let start, end;
if (ranges.length !== 0) {
  start = Math.min(...ranges.map(e => e.start));
  end = Math.max(...ranges.map(e => e.end));
} else {
  [start, end] = d3.extent(eventsToDraw.map(e => e.year))
}
const yearColorScale = Plot.scale({
  color: {
    scheme: colorScheme, domain: [start, end]
  }
});
```

```js
function stripHtml(element) {
  let tmp = document.createElement('div');
  tmp.innerHTML = element;
  return tmp.innerText || "";
}
```

```js
// This function accepts a city name and generates the tooltip.
// It should return raw HTML code.
function tipText(description) {
  const d = events.filter((e) => e.description == description)[0];
  const year = `${Math.abs(d.year)} ${d.year < 0 ? 'BC' : 'AD'}`;
  return `<h4>${d.day} ${d.month}, ${year}</h4> ${d.description}`;
}
```

```js
function set(input, value) {
  input.value = value;
  input.dispatchEvent(new Event("input"), {bubbles: true})
}
```

```js
function yearFormat(year) {
  return `${Math.abs(year)} ${year < 0 ? 'BC' : 'AD'}`;
}
```

```js
const events = await FileAttachment('data/events.json').json();
```

```js
const start = Math.min(...ranges.map(e => e.start));
const end = Math.max(...ranges.map(e => e.end));
const eventsToDraw = searchTerms.length === 0 ?
  events.filter(e => e.year >= start && e.year <= end) : 
  events.filter(e => tokenize(searchTerms).some(t => stripHtml(e.description).includes(t)));
```

```js
function tokenize(input) {
    const regex = /"([^"]*)"|\S+/g;
    let match;
    const tokens = [];
  
    while ((match = regex.exec(input)) !== null) {
        // If content was quoted, add the capture group to the list.
        // Otherwise, add the match as is.
        tokens.push(match[1] ? match[1] : match[0]);
    }
  
    return tokens;
}

```

```js
const world = await FileAttachment("data/land-50m.json").json();
const land = topojson.feature(world, world.objects.land);
```

```js
import tippy from 'npm:tippy.js@6';
```

```js
function calculateStepSize(year) {
  const currentYear = new Date().getFullYear();
  const distance = Math.abs(currentYear - year); // Year might be negative for BC

  if (distance > 500) {
    return 100;
  } else if (distance > 200) {
    return 50;
  } else if (distance > 100) {
    return 20;
  } else {
    return 5;
  }
}
```
